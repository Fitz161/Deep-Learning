事件是系统内发生的动作或者发生的事情，系统响应事件后，如果需要，您可以某种方式对事件做出回应
在 Web 中, 事件在浏览器窗口中被触发并且通常被绑定到窗口内部的特定部分 — 可能是一个元素、一系列元素、被加载到这个窗口的 HTML 代码或者是整个浏览器窗口。举几个可能发生的不同事件：

用户在某个元素上点击鼠标或悬停光标。click focus
用户在键盘中按下某个按键。
用户调整浏览器的大小或者关闭浏览器窗口。
一个网页停止加载。
提交表单。
播放、暂停、关闭视频。
发生错误。

每个可用的事件都会有一个事件处理器，也就是事件触发时会运行的代码块。当我们定义了一个用来回应事件被激发的代码块的时候，我们说我们注册了一个事件处理器。注意事件处理器有时候被叫做事件监听器——从我们的用意来看这两个名字是相同的，尽管严格地来说这块代码既监听也处理事件。监听器留意事件是否发生，然后处理器就是对事件发生做出的回应。


使用网页事件的方式
1.事件处理器属性 btn.onclick = function(){} 匿名函数
function f(){}   btn.onclick = f; 直接将函数（不加括号）赋值给属性
这个 onclick 是被用在这个情景下的事件处理器的属性，它就像 button 其他的属性（如 btn.textContent, or btn.style), 但是有一个特别的地方——当您将一些代码赋值给它的时候，只要事件触发代码就会运行。

btn.onfocus及btn.onblur — 颜色将于按钮被置于焦点（选中）或解除焦点时改变（尝试使用Tab移动至按钮上，然后再移开）。这些通常用于显示有关如何在置于焦点时填写表单字段的信息，或者如果表单字段刚刚填入不正确的值，则显示错误消息。
btn.ondblclick — 颜色将仅于按钮被双击时改变。

window.onkeypress, window.onkeydown, window.onkeyup — 当键盘被按下时颜色会发生改变. keypress 指的是通俗意义上的按下keyboard (按下并松开), 而 keydown 和 keyup 指的是按键动作的一部分,分别指按下和松开. 注意如果你将事件处理器添加到按钮本身，它将不会工作 — 我们只能将它添加到代表整个浏览器窗口的 window对象中。
btn.onmouseover 和 btn.onmouseout — 颜色将会在鼠标移入按钮上方时发生改变, 或者当它从按钮移出时.

2.行内事件处理器 - 请勿使用
<button onclick="alert('Hello, this is my old-fashioned event handler!');">Press me</button>

3.addEventListener() 和removeEventListener()
在addEventListener() 函数中, 我们具体化了两个参数——我们想要将处理器应用的事件名称，和包含我们用来回应事件的函数的代码（将这些代码全部放到一个匿名函数中是可行的）或已定义好的函数的函数名
removeEventListener()，这个方法移除事件监听器

可以给同一个监听器注册多个处理器，需要用removeEventListener()方法，
直接用事件属性（如btn.onclick = func;）不可行，这样后来的会将前面的覆盖

事件对象
有时候在事件处理函数内部，您可能会看到一个固定指定名称的参数，例如event，evt或简单的e。 这被称为事件对象，它被自动传递给事件处理函数，以提供额外的功能和信息
e.target属性始终是产生该事件的元素的引用，
function bgChange(e) {
  const rndCol = 'rgb(' + random(255) + ',' + random(255) + ',' + random(255) + ')';
  e.target.style.backgroundColor = rndCol;
  console.log(e);
}
btn.addEventListener('click', bgChange);
中，btn被点击后，会调用bgChange函数，并传入e参数，函数里用e.target可以获取btn这个引用
这里e只是起到一个形式参数的作用，其名称无所谓，可随便起

当您要在多个元素上设置相同的事件处理程序时，e.target非常有用，能用于获取一系列元素中发生事件的那个元素并进行操作

阻止默认行为
preventDefault()

对事件冒泡和捕捉的解释event capturing and bubbling
当一个事件发生在具有父元素的元素上,现代浏览器运行两个不同的阶段 - 捕获阶段和冒泡阶段。 在捕获阶段：
浏览器检查元素的最外层祖先<html>，是否在捕获阶段中注册了一个onclick事件处理程序，如果是，则运行它。
然后，它移动到<html>中单击元素的下一个祖先元素，并执行相同的操作，然后是单击元素再下一个祖先元素，依此类推，直到到达实际点击的元素。
在冒泡阶段，恰恰相反:
浏览器检查实际点击的元素是否在冒泡阶段中注册了一个onclick事件处理程序，如果是，则运行它
然后它移动到下一个直接的祖先元素，并做同样的事情，然后是下一个，等等，直到它到达<html>元素。

在现代浏览器中，默认情况下，所有事件处理程序都在冒泡阶段进行注册,从低到高，从子到父
stopPropagation()的函数, 当在事件对象上调用该函数时，它只会让当前事件处理程序运行，但事件不会在冒泡链上进一步扩大，因此将不会有更多事件处理器被运行(不会向上冒泡)。
默认情况下，所有事件处理程序都是在冒泡阶段注册的
如果您真的想在捕获阶段注册一个事件，那么您可以通过使用addEventListener()注册您的处理程序，并将可选的第三个属性设置为true。
